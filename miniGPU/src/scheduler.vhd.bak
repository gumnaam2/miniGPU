library ieee;
use ieee.std_logic_1164.all;

-- Sets the state (core_state) of the FSM and thus schedules the signals being sent to various parts of the machine
entity scheduler is port(
	clock, reset, start  					: in std_logic;
	decoded_ret									: in std_logic; --whether the program end is reached
	mem_read_enable, mem_write_enable	: in std_logic; --enable read/write from the memory
	fetcher_state	: in std_logic_vector(2 downto 0);
	lsu_state		: in std_logic_vector(1 downto 0);
	new_pc			: in std_logic_vector(7 downto 0); --next program line to be fetched
	
	core_state		: out std_logic_vector(2 downto 0);
	current_pc		: out std_logic_vector(7 downto 0);
	done				: out std_logic
);

end scheduler;


architecture fsm of scheduler is
	type fsm_state is std_logic_vector(2 downto 0);
	constant IDLE : fsm_state := "000"; --wait for start to go high
	constant FETCH : fsm_state := "001"; --send current_pc to instr mem, wait for fetcher_state to be FETCHED
	constant DECODE : fsm_state := "010"; --send program line to decoder, wait for mem_read_enable, mem_write_enable, decoded_ret
	constant REQUEST : fsm_state := "011"; --send data to LSUs if needed
	constant WAIT_state : fsm_state := "100"; --wait for all LSUs to perform the load/store operations
	constant EXECUTE : fsm_state := "101"; --ALU, branch, pc calculations read
	constant UPDATE : fsm_state := "110"; --write to RF, next_pc
	constant DONE : fsm_state := "111"; --activated by decoded_ret, only reset gets IDLE state back
begin
process(clock) begin
	if rising_edge(clock) then
		if reset = '1' then
			core_state <= IDLE; current_pc <= (others => '0'); done <= '0';
		else
			if core_state = IDLE then
				if start = '1' then
					state <= FETCH;
				end if;
			end if;
		end if;
	end if;
end process;	
end fsm;